/**
 * Daily Inspo - Frontend Application
 * 
 * Handles UI interactions, API communication, and idea display
 * functionality for the automated app idea generator.
 */

class DailyInspoApp {
    constructor() {
        this.currentPage = 1;
        this.totalPages = 1;
        this.currentFilters = {};
        this.ideas = [];
        
        this.init();
    }

    /**
     * Initialize application
     */
    async init() {
        try {
            this.bindEventListeners();
            await this.loadSystemStats();
            await this.loadFilterOptions();
            await this.loadIdeas();
        } catch (error) {
            console.error('Failed to initialize application:', error);
            this.showError('Failed to initialize application');
        }
    }

    /**
     * Bind event listeners to DOM elements
     */
    bindEventListeners() {
        // Search functionality
        const searchInput = document.getElementById('search-input');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    this.applyFilters();
                }, 500); // Debounce search
            });
        }

        // Filter controls
        const applyFiltersBtn = document.getElementById('apply-filters');
        if (applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', () => this.applyFilters());
        }

        const clearFiltersBtn = document.getElementById('clear-filters');
        if (clearFiltersBtn) {
            clearFiltersBtn.addEventListener('click', () => this.clearFilters());
        }

        const randomIdeaBtn = document.getElementById('random-idea');
        if (randomIdeaBtn) {
            randomIdeaBtn.addEventListener('click', () => this.showRandomIdea());
        }

        // Pagination buttons
        const prevPageBtn = document.getElementById('prev-page');
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => {
                if (this.currentPage > 1) {
                    this.navigateToPage(this.currentPage - 1);
                }
            });
        }

        const nextPageBtn = document.getElementById('next-page');
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => {
                if (this.currentPage < this.totalPages) {
                    this.navigateToPage(this.currentPage + 1);
                }
            });
        }

        // Modal controls
        const modalClose = document.getElementById('modal-close');
        if (modalClose) {
            modalClose.addEventListener('click', () => this.hideIdeaModal());
        }

        const modalBackdrop = document.querySelector('.modal__backdrop');
        if (modalBackdrop) {
            modalBackdrop.addEventListener('click', () => this.hideIdeaModal());
        }

        // ESC key to close modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideIdeaModal();
            }
        });
    }

    /**
     * Load system statistics and update header
     */
    async loadSystemStats() {
        try {
            const stats = await this.apiRequest('/api/ideas/stats/');
            
            // Update header stats
            const totalElement = document.getElementById('stats-total');
            if (totalElement) {
                totalElement.textContent = stats.total_ideas || 0;
            }
            
            const lastElement = document.getElementById('stats-last');
            if (lastElement && stats.last_generation) {
                const lastDate = new Date(stats.last_generation);
                lastElement.textContent = this.formatDate(lastDate.toISOString());
            } else if (lastElement) {
                lastElement.textContent = 'Never';
            }
        } catch (error) {
            console.error('Failed to load system stats:', error);
        }
    }

    /**
     * Load available filter options from API
     */
    async loadFilterOptions() {
        try {
            // Load industries
            const industries = await this.apiRequest('/api/filters/industries/');
            this.populateSelect('industry-filter', industries);
            
            // Load technologies
            const technologies = await this.apiRequest('/api/filters/technologies/');
            this.populateSelect('technology-filter', technologies);
            
            // Complexity and target market are already populated in HTML
        } catch (error) {
            console.error('Failed to load filter options:', error);
        }
    }

    /**
     * Load ideas from API with current filters
     */
    async loadIdeas() {
        this.showLoading();
        
        try {
            const params = {
                ...this.currentFilters,
                limit: 50,
                offset: (this.currentPage - 1) * 50
            };
            
            const queryString = this.buildQueryString(params);
            const response = await this.apiRequest(`/api/ideas/search/?${queryString}`);
            
            this.ideas = response.ideas || [];
            this.renderIdeasGrid(this.ideas);
            
            // Update pagination
            this.totalPages = Math.ceil(response.total_count / 50);
            this.updatePagination(this.currentPage, this.totalPages, response.has_more);
            
        } catch (error) {
            console.error('Failed to load ideas:', error);
            this.showError('Failed to load ideas');
            this.showEmptyState();
        } finally {
            this.hideLoading();
        }
    }

    /**
     * Render idea cards in the grid
     */
    renderIdeasGrid(ideas) {
        const grid = document.getElementById('ideas-grid');
        
        if (ideas.length === 0) {
            this.showEmptyState();
            return;
        }

        // Clear existing content
        grid.innerHTML = '';
        
        // Render each idea card
        ideas.forEach(idea => {
            const card = this.createIdeaCard(idea);
            grid.appendChild(card);
        });
        
        // Ensure grid is visible
        document.getElementById('empty-state').classList.add('hidden');
    }

    /**
     * Create HTML element for individual idea card
     */
    createIdeaCard(idea) {
        const card = document.createElement('div');
        card.className = 'idea-card';
        card.dataset.ideaId = idea.id;
        
        // Add click handler for modal
        card.addEventListener('click', () => this.showIdeaModal(idea.id));
        
        // Create tags HTML
        const tagsHtml = idea.tags.map(tag => 
            `<span class="tag tag--${tag.category}">${tag.value}</span>`
        ).join('');
        
        // Create card HTML structure
        card.innerHTML = `
            <h3 class="idea-card__title">${this.escapeHtml(idea.title)}</h3>
            <p class="idea-card__summary">${this.escapeHtml(idea.summary)}</p>
            <div class="idea-card__tags">${tagsHtml}</div>
            <div class="idea-card__meta">
                <span>${this.formatDate(idea.generated_date)}</span>
                <span>Click to view details</span>
            </div>
        `;
        
        return card;
    }

    /**
     * Create tag element with appropriate styling
     */
    createTagElement(tag) {
        const tagEl = document.createElement('span');
        tagEl.className = `tag tag--${tag.category}`;
        tagEl.textContent = tag.value;
        return tagEl;
    }

    /**
     * Show detailed idea modal
     */
    async showIdeaModal(ideaId) {
        try {
            this.showLoading();
            
            // Fetch detailed idea data
            const idea = await this.apiRequest(`/api/ideas/${ideaId}`);
            
            // Populate modal content
            document.getElementById('modal-title').textContent = idea.title;
            
            const modalContent = document.getElementById('modal-content');
            
            // Create tags HTML
            const tagsHtml = idea.tags.map(tag => 
                `<span class="tag tag--${tag.category}">${tag.value}</span>`
            ).join('');
            
            // Create competitors list
            const competitorsHtml = idea.market_data?.competitors ? 
                '<ul>' + idea.market_data.competitors.map(comp => `<li>${this.escapeHtml(comp)}</li>`).join('') + '</ul>' :
                '<p>Not specified</p>';
            
            modalContent.innerHTML = `
                <div class="modal__section">
                    <h3>Summary</h3>
                    <p>${this.escapeHtml(idea.summary)}</p>
                </div>
                
                <div class="modal__section">
                    <h3>Description</h3>
                    <p>${this.escapeHtml(idea.description)}</p>
                </div>
                
                <div class="modal__section">
                    <h3>Supporting Logic</h3>
                    <p>${this.escapeHtml(idea.supporting_logic)}</p>
                </div>
                
                <div class="modal__section">
                    <h3>Tags</h3>
                    <div class="idea-card__tags">${tagsHtml}</div>
                </div>
                
                ${idea.market_data ? `
                <div class="modal__section">
                    <h3>Market Analysis</h3>
                    <p><strong>Market Size:</strong> ${this.escapeHtml(idea.market_data.market_size || 'Not specified')}</p>
                    <p><strong>Technical Feasibility:</strong> ${this.escapeHtml(idea.market_data.technical_feasibility || 'Not assessed')}</p>
                    <p><strong>Development Timeline:</strong> ${this.escapeHtml(idea.market_data.development_timeline || 'Not estimated')}</p>
                    <div>
                        <strong>Key Competitors:</strong>
                        ${competitorsHtml}
                    </div>
                </div>
                ` : ''}
                
                <div class="modal__section">
                    <h3>Generated</h3>
                    <p>${this.formatDate(idea.generated_date)}</p>
                </div>
            `;
            
            // Show modal
            document.getElementById('idea-modal').classList.remove('hidden');
            
        } catch (error) {
            console.error('Failed to load idea details:', error);
            this.showError('Failed to load idea details');
        } finally {
            this.hideLoading();
        }
    }

    /**
     * Hide idea modal
     */
    hideIdeaModal() {
        const modal = document.getElementById('idea-modal');
        modal.classList.add('hidden');
    }

    /**
     * Apply current filters and reload ideas
     */
    async applyFilters() {
        this.currentFilters = this.collectFilterValues();
        this.currentPage = 1;
        await this.loadIdeas();
    }

    /**
     * Collect current filter values from form elements
     */
    collectFilterValues() {
        const filters = {};
        
        // Collect search query
        const searchInput = document.getElementById('search-input');
        if (searchInput?.value?.trim()) {
            filters.q = searchInput.value.trim();
        }
        
        // Collect filter selections
        const industrySelect = document.getElementById('industry-filter');
        if (industrySelect) {
            const selectedIndustries = Array.from(industrySelect.selectedOptions).map(opt => opt.value);
            if (selectedIndustries.length > 0) {
                filters.industry = selectedIndustries;
            }
        }
        
        const complexitySelect = document.getElementById('complexity-filter');
        if (complexitySelect) {
            const selectedComplexity = Array.from(complexitySelect.selectedOptions).map(opt => opt.value);
            if (selectedComplexity.length > 0) {
                filters.complexity = selectedComplexity;
            }
        }
        
        const technologySelect = document.getElementById('technology-filter');
        if (technologySelect) {
            const selectedTech = Array.from(technologySelect.selectedOptions).map(opt => opt.value);
            if (selectedTech.length > 0) {
                filters.technology = selectedTech;
            }
        }
        
        const marketSelect = document.getElementById('market-filter');
        if (marketSelect) {
            const selectedMarkets = Array.from(marketSelect.selectedOptions).map(opt => opt.value);
            if (selectedMarkets.length > 0) {
                filters.target_market = selectedMarkets;
            }
        }
        
        return filters;
    }

    /**
     * Clear all filters and reload
     */
    async clearFilters() {
        this.currentFilters = {};
        this.currentPage = 1;
        
        // Clear form elements
        const searchInput = document.getElementById('search-input');
        if (searchInput) searchInput.value = '';
        
        const selects = [
            'industry-filter',
            'complexity-filter', 
            'technology-filter',
            'market-filter'
        ];
        
        selects.forEach(selectId => {
            const select = document.getElementById(selectId);
            if (select) {
                Array.from(select.options).forEach(option => {
                    option.selected = false;
                });
            }
        });
        
        await this.loadIdeas();
    }

    /**
     * Load and show random idea
     */
    async showRandomIdea() {
        try {
            const randomIdea = await this.apiRequest('/api/ideas/random/');
            await this.showIdeaModal(randomIdea.id);
        } catch (error) {
            console.error('Failed to load random idea:', error);
            if (error.message.includes('404')) {
                this.showError('No ideas available yet');
            } else {
                this.showError('Failed to load random idea');
            }
        }
    }

    /**
     * Handle pagination navigation
     */
    async navigateToPage(page) {
        if (page < 1 || page > this.totalPages) {
            return;
        }
        
        this.currentPage = page;
        await this.loadIdeas();
    }

    /**
     * Update pagination controls
     */
    updatePagination(currentPage, totalPages, hasMore) {
        this.currentPage = currentPage;
        this.totalPages = totalPages;
        
        // Update button states
        const prevBtn = document.getElementById('prev-page');
        const nextBtn = document.getElementById('next-page');
        const pageInfo = document.getElementById('page-info');
        
        if (prevBtn) {
            prevBtn.disabled = currentPage <= 1;
        }
        
        if (nextBtn) {
            nextBtn.disabled = currentPage >= totalPages;
        }
        
        if (pageInfo) {
            pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1}`;
        }
    }

    /**
     * Show loading state
     */
    showLoading() {
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('ideas-grid').classList.add('hidden');
        document.getElementById('empty-state').classList.add('hidden');
    }

    /**
     * Hide loading state
     */
    hideLoading() {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('ideas-grid').classList.remove('hidden');
    }

    /**
     * Show empty state when no ideas found
     */
    showEmptyState() {
        document.getElementById('ideas-grid').classList.add('hidden');
        document.getElementById('empty-state').classList.remove('hidden');
    }

    /**
     * Show error message
     */
    showError(message) {
        // TODO: Implement error display
        console.error(message);
        // Could add toast notification or error banner
    }

    /**
     * Format date for display
     */
    formatDate(dateString) {
        // TODO: Implement date formatting
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });
    }

    /**
     * Truncate text to specified length
     */
    truncateText(text, maxLength = 150) {
        if (text.length <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength).trim() + '...';
    }

    /**
     * Build query string from filter parameters
     */
    buildQueryString(params) {
        // TODO: Implement query string building
        const queryParams = new URLSearchParams();
        
        Object.entries(params).forEach(([key, value]) => {
            if (value !== null && value !== undefined && value !== '') {
                if (Array.isArray(value)) {
                    value.forEach(v => queryParams.append(key, v));
                } else {
                    queryParams.append(key, value);
                }
            }
        });
        
        return queryParams.toString();
    }

    /**
     * Make API request with error handling
     */
    async apiRequest(url, options = {}) {
        // TODO: Implement API request wrapper
        try {
            const response = await fetch(url, {
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                },
                ...options
            });

            if (!response.ok) {
                throw new Error(`API request failed: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('API request failed:', error);
            throw error;
        }
    }
}

// Initialize application when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.dailyInspoApp = new DailyInspoApp();
});

// Export for potential testing or external access
if (typeof module !== 'undefined' && module.exports) {
    module.exports = DailyInspoApp;
}